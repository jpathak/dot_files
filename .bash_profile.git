#!/bin/sh
########################################################################################################################
# GIT COMMANDS -
# A repository of git commands wrapped in a number-referencing wrapper
# which makes it easy to run subsequent commands
########################################################################################################################

#
# Function to get the filename from the
# results stored in array
#
function gf() {
    if [[ ! $1 ]] ; then
        echo "Error! No argument to get_filename!"
        exit 1
    fi
    echo ${gfr[$1 - 1]} | 
        sed -E "s/"$'\E'"\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g" | 
        awk '{ print $NF }' | 
        tr -d '[[:cntrl:]]'
}

is_num_result=""

#
# Is the argument a number ?
#
function is_num() {
    if [[ $1 =~ ^-?[0-9]+$ ]]; then
        is_num_result="yes"
    else
        is_num_result="no"
    fi
}

#
# Is the command being run a generating command
# (From which you choose something later, eg
# git status gives a list of modified files and
# you choose a file to open or diff, or
# git branch gives a list of branches to checkout)
#
is_generating_command="no"
function is_gen_command() {
    # Currently only two generating commands
    if [[ $1 == "status" ||
          $1 == "branch" ]]; then
        is_generating_command="yes"
    else
        is_generating_command="no"
    fi
}

clean="no"

#
# Is my workspace dirty ? (for this branch)
#
function is_workspace_dirty() { if [[ ${gfr[@]} =~ "working directory clean" ]]; then clean="yes"; else clean="no"; fi }

#
# Run a git command with special conditions
# Examples of conditions include:
# 1) Is this a generating command ?
# 2) Is the argument to the command a number ?
#
function git_command() {
    clean="yes"
    is_gen_command $1
    OLDIFS=$IFS
    if [[ $is_generating_command == "yes" ]]; then
        gfr=()
        IFS=$'\n' gfr=($(script -q /dev/null git $1 | nl))
        is_workspace_dirty
        if [[ $1 == "status" && $clean == "yes" ]]; then
            git $1;
        else
            printf '%s\n' "${gfr[@]}"
        fi
    else
        is_num $2
        if [[ $is_num_result == "yes" ]]; then
            git $1 $(gf $2)
        else
            git $1 $2
        fi
    fi
    IFS=$OLDIFS
}

#
# Function to find (and open if found) files
# Arguments can include the filename or
# optionally a number which is an option
# from a previously run generating command.
#
function fo() {
    is_num $1
    if [[ $is_num_result == "yes" ]]; then
        emacs -nw `gf $1`
    else
        find . -name "$1" -exec emacs -nw {} \;
    fi
}

#
# Array to store results of generating commands
#
gfr=()

#
# Aliases for the most commonly used git commands
# Usage:
# <command> [optional line number] <arguments that may follow the original command>
#
function gch() { filename=$(gf $1); git checkout $2 $filename; }
alias gd='git_command diff '
alias ga='git_command add '
alias gl='git_command log '
alias gan='git_command annotate '
alias gr='git_command reset '
alias gs='git_command status'
alias gb='git_command branch'
alias g='git'
alias grp='git review post'
alias grs='git review submit'
alias gro='git review open'
alias gsh='git show'
alias gp='kinit; git pull'

#
# TODO list! (Help me out! :) )
#
# AWESOME if fo could autocomplete filenames to open
# perhaps: http://unix.stackexchange.com/questions/28283/autocomplete-of-filename-in-directory

########################################################################################################################
