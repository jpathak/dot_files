#!/bin/sh
# WARNING: WIP!!
#
# Function to search a codebase for a tag
# Use the command cindex to generate the index
# and the env var CSEARCHINDEX to be able to locate it
#
csr=()
#
# Function f 'find' (a tag in code)
# Usage:
# f <text to find> [filetype]
#
function f() {
    #
    # Check if this is a git repository
    #
    if [[ $(git rev-parse --show-toplevel) ]]; then
        #
        # Set csearchindex to the top of the development directory of this
        # git repo
        #
        CSEARCHINDEX="$(git rev-parse --show-toplevel)"/.csearchindex
        #
        # Create the search index if it doesn't exist already in the repo path
        #
        if [[ ! -e $CSEARCHINDEX ]]; then
            echo "First run in a git repo! Creating search index at repo root"
            pushd $(git rev-parse --show-toplevel)
            cindex .
            popd
            #
            # Exclude search index from git changes
            #
            echo ".csearchindex" >> "$(git rev-parse --show-toplevel)"/.git/info/exclude
        fi
    else
        CSEARCHINDEX=""
    fi

    csr=()
    extension=".*"
    if (( "$#" == 2 )) ; then
        extension=$2
    fi
    OLDIFS=$IFS

    #
    # using "script" preserves color formatting
    # which can be then piped into the csr array
    # Regular search runs on grep
    #
    echo "Searching files of type (regex): $extension"
    if [[ ! -e $CSEARCHINDEX ]]; then
        echo "Using regular search..."
        IFS=$'\n' csr=($(script -q /dev/null find . \
               -name "*.$extension" \
               -exec grep --mmap -rnie "$1" {} \; | nl))
    else
        echo "Using indexed search, index=$CSEARCHINDEX"
        #
        # "Fast" search runs on csearch
        #
        IFS=$'\n' csr=($(script -q /dev/null csearch -f "$extension\$" -n "$1" | grep --color=always "$1" | nl))
    fi

    printf '%s\n' "${csr[@]}"
    IFS=$OLDIFS
    
    #
    # If only one result, take me there already!
    #
    if [ ${#csr[@]} -eq 1 ]; then
        r 1
    fi
}

#
# Reference the code results generated above in f()
# Usage:
# r <number against line number of result>
#
function r() {
    openEditorAt $(gfr $1)
}

#
# Useful function to open results in sublime text editor,
# you need to have set it up from instructions here:
# https://www.sublimetext.com/docs/2/osx_command_line.html
# Usage:
# sr <number against line number of result>
#
function sr() {
    EDITOR=subl openEditorAt $(gfr $1)
}

#
# Utility function to get the filename at line number
#
function gfr() {
    echo ${csr[$1 - 1]} | sed -E "s/"$'\E'"\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g" | perl -pe's/^.*[0-9]+\s+([^\s:]*):([0-9]+):.*$/\1 \2/'
}

#
# Utility function to open a file at line number
# Usage:
# openEditorAt <file> <lineno>
#
function openEditorAt() {
    if [[ $EDITOR =~ "emacs" ]]; then
        $EDITOR +$2 $1
    else
        $EDITOR $1:$2
    fi
}

#
# With all the stuff around bash and colors,
# this command is useful to find out what exactly being
# displayed on the terminal
# Usage:
# ls | show_hidden
#
alias show_hidden="tr -dc '[:print:]' | od -c"
