#!/bin/sh
# WARNING: WIP!!
#
# Function to search a codebase for a tag
# Use the command cindex to generate the index
# and the env var CSEARCHINDEX to be able to locate it
#
csr=()
#
# Function f 'find' (a tag in code)
# Usage:
# f <text to find> [filetype]
#
function f() {

    is_git_command=0
    #
    # Check if this is a git repository
    #
    if [[ $(git rev-parse --show-toplevel) ]]; then
        #
        # Set csearchindex to the top of the development directory of this
        # git repo
        #
        export CSEARCHINDEX="$(git rev-parse --show-toplevel)"/.csearchindex
        #
        # Create the search index if it doesn't exist already in the repo path
        #
        if [[ ! -e $CSEARCHINDEX ]]; then
            echo "First run in a git repo! Creating search index at repo root"
            pushd $(git rev-parse --show-toplevel)
            cindex .
            popd
            #
            # Exclude search index from git changes
            #
            echo ".csearchindex" >> "$(git rev-parse --show-toplevel)"/.git/info/exclude
        fi
    else
        CSEARCHINDEX=""
    fi

    csr=()
    extension=".*"
    if (( "$#" == 2 )) ; then
        extension=$2
    fi
    OLDIFS=$IFS

    #
    # using "script" preserves color formatting
    # which can be then piped into the csr array
    # Regular search runs on grep
    #
    echo "Searching files of type (regex): $extension"
    if [[ ! -e $CSEARCHINDEX ]]; then
        echo "Using regular search..."
        IFS=$'\n' csr=($(script -q /dev/null find . \
               -name "*.$extension" \
               -exec grep --mmap -rnie "$1" {} \; | nl))
    else
        echo "Using indexed search, index=$CSEARCHINDEX"
        #
        # "Fast" search runs on csearch
        #
        IFS=$'\n' csr=($(script -q /dev/null csearch -f "$extension\$" -n "$1" | grep --color=always "$1" | nl -d '\n'))
    fi

    printf '%s\n' "${csr[@]}"
    IFS=$OLDIFS
    
    #
    # If only one result, take me there already!
    #
    if [ ${#csr[@]} -eq 1 ]; then
        r 1
    fi
}

#
# Reference the code results generated above in f()
# Usage:
# r <number against line number of result>
#
function r() {
    openEditorAt $(resolve $1)
}

#
# Useful function to open results in sublime text editor,
# you need to have set it up from instructions here:
# https://www.sublimetext.com/docs/2/osx_command_line.html
# Usage:
# sr <number against line number of result>
#
function sr() {
    EDITOR=subl openEditorAt $(resolve $1)
}

#
# Utility function to get the filename at line number
# from the catch-all array csr
#
function resolve() {
    with_linenum=${2:-1}
    temp=$(echo ${csr[$1 - 1]} | sed -E "s/"$'\E'"\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g")
    if [[ $is_git_command == 1 ]]; then
        echo $temp | 
        awk '{ print $NF }' | 
        tr -d '[[:cntrl:]]'
    else
	if [[ $with_linenum == 1 ]]; then
	    echo $temp | perl -pe's/^\s*[0-9]+\s+([^\s:]*):*([0-9]+)*:*.*$/\1 \2/'
        else
	    echo $temp | perl -pe's/^\s*[0-9]+\s+([^\s:]*):*([0-9]+)*:*.*$/\1/'
        fi
    fi
}

#
# Utility function to open a file at line number
# Usage:
# openEditorAt <file> <lineno>
#
function openEditorAt() {
    if [[ -z $2 ]]; then
        $EDITOR $1
    else
        if [[ $EDITOR =~ "emacs" ]]; then
            $EDITOR +$2 $1
        else
            $EDITOR $1:$2
        fi
    fi
}

#
# Utility function to compare versions
#
function compare_version_lesser() {
    test "$(echo "$@" | tr " " "\n" | sort -nr | head -n 1)" != "$1";
}

#
# With all the stuff around bash and colors,
# this command is useful to find out what exactly being
# displayed on the terminal
# Usage:
# ls | show_hidden
#
alias show_hidden="tr -dc '[:print:]' | od -c"
alias ci='CSEARCHINDEX="$(git rev-parse --show-toplevel)"/.csearchindex; cindex .' 

#!/bin/sh
########################################################################################################################
# GIT COMMANDS -
# A repository of git commands wrapped in a number-referencing wrapper
# which makes it easy to run subsequent commands
########################################################################################################################

#
# Is the argument a number ?
#
is_num_result=""
function is_num() {
    if [[ $1 =~ ^-?[0-9]+$ ]]; then
        is_num_result="yes"
    else
        is_num_result="no"
    fi
}

#
# Is the command being run a generating command
# (From which you choose something later, eg
# git status gives a list of modified files and
# you choose a file to open or diff, or
# git branch gives a list of branches to checkout)
#
is_generating_command="no"
function is_gen_command() {
    # Currently only two generating commands
    if [[ $1 == "status" ||
          $1 == "branch" ]]; then
        is_generating_command="yes"
    else
        is_generating_command="no"
    fi
}

clean="no"


#
# Is my workspace dirty ? (for this branch)
#
function is_workspace_dirty() { 
    if [[ ${csr[@]} =~ "working directory clean" ]]; then 
        clean="yes"; else clean="no"; 
    fi 
}

#
# Run a git command with special conditions
# Examples of conditions include:
# 1) Is this a generating command ?
# 2) Is the argument to the command a number ?
#
is_git_command=0
function git_command() {
    clean="yes"
    is_gen_command $1
    OLDIFS=$IFS
    #
    # Either there was a git generating command or
    # a f() generating command
    #
    if [[ $is_generating_command == "yes" ]]; then
        is_git_command=1
        csr=()
        IFS=$'\n' csr=($(script -q /dev/null git $1 $2 | nl))
        is_workspace_dirty
        if [[ $1 == "status" && $clean == "yes" ]]; then
            git $1 $2;
        else
            printf '%s\n' "${csr[@]}"
        fi
    else
    	is_num $2
        if [[ $is_num_result == "yes" ]]; then
            git $1 $3 $(resolve $2 0)
        else
            # $3 is any other options which were given
            git $1 $3 $2
        fi
    fi
    IFS=$OLDIFS
}

#
# Function to find (and open if found) files
# Arguments can include the filename or
# optionally a number which is an option
# from a previously run generating command.
#
function fo() {
    is_num $1
    # open dir option only applicable for numbered arguments
    # since there can be many matches for an arbitrary filename
    open_dir=${2:-0}
    if [[ $is_num_result == "yes" ]]; then
        if [[ $open_dir == 1 ]]; then
            pushd $(dirname $(resolve $1 0))
        else
            openEditorAt $(resolve $1)
        fi
    else
	OLDIFS=$IFS
	IFS=$'\n' csr=($(script -q /dev/null find . -name "$1" | nl))
	printf '%s\n' "${csr[@]}"
	IFS=$OLDIFS

	#
	# If only one result, take me there already!
	#
	if [ ${#csr[@]} -eq 1 ]; then
	    r 1
	fi
        #find . -name "$1" -exec $EDITOR {} \;
    fi
}

#
# Aliases for the most commonly used git commands
# Usage:
# <command> [optional line number] <arguments that may follow the original command>
#
#function gch() { filename=$(resolve $1 0); git checkout $2 $filename; }
alias gch='git_command checkout'
alias gd='git_command diff '
alias ga='git_command add '
alias gl='git_command log '
alias gan='git_command annotate '
alias gr='git_command reset '
alias gs='git_command status'
alias gb='git_command branch'
alias g='git'
alias grp='git review post'
alias grs='git review submit'
alias gro='git review open'
alias gsh='git show'
alias gp='kinit; git pull'

#
# TODO list! (Help me out! :) )
#
# AWESOME if fo could autocomplete filenames to open
# perhaps: http://unix.stackexchange.com/questions/28283/autocomplete-of-filename-in-directory

########################################################################################################################



