#!/bin/sh
# WARNING: WIP!!

# Check if csearch exists
if [[ ! $(which csearch) =~ "csearch" ]]; then
    echo "csearch not found! Please install csearch "
        "(https://github.com/google/codesearch) before continuing"
    exit 1
fi

#
# Function f 'find' (a tag in code)
# Use the command cindex to generate the index
# and the env var CSEARCHINDEX to be able to locate it
# Usage:
# f <text to find> [filetype]
#
csr=()
function f() {

    is_git_command=0

    # Update CSEARCHINDEX
    update_csearch

    csr=()
    extension=".*"
    if (( "$#" == 2 )) ; then
        extension=$2
    fi
    OLDIFS=$IFS

    # using "script" preserves color formatting
    # which can be then piped into the csr array
    # Regular search runs on grep
    echo "Searching files of type (regex): $extension"
    if [[ ! -e $CSEARCHINDEX ]]; then
        echo "Using regular search..."
        IFS=$'\n' csr=($(script -q /dev/null find . -name "*.$extension" -exec grep --mmap -rnie "$1" {} \; | nl))
    else
        echo "Using indexed search, index=$CSEARCHINDEX"

        # "Fast" search runs on csearch
        IFS=$'\n' csr=($(script -q /dev/null csearch -f "$extension\$" -n "$1" | grep --color=always "$1" | nl -d '\n'))
    fi

    printf '%s\n' "${csr[@]}"
    IFS=$OLDIFS

    # If only one result, take me there already!
    if [ ${#csr[@]} -eq 1 ]; then
        r 1
    fi
}

function update_csearch() {

    # Check if this is a git repository
    if [[ $(git rev-parse --show-toplevel) ]]; then

        # Set csearchindex to the top of the development directory of this
        # git repo
        export CSEARCHINDEX="$(git rev-parse --show-toplevel)"/.csearchindex

        # Create the search index if it doesn't exist already in the repo path
        if [[ ! -e $CSEARCHINDEX ]] || [[ $1 ]]; then
            pushd $(git rev-parse --show-toplevel)
            cindex .
            popd

            # Exclude search index from git changes
            printf ".csearchindex\n" >> "$(git rev-parse --show-toplevel)"/.git/info/exclude
        fi
    else
        CSEARCHINDEX=""
    fi
}

# Reference the code results generated above in f()
# Usage:
# r <number against line number of result>
function r() {
    OLDIFS=$IFS
    IFS=$' '
    openEditorAt $(resolve $1)
    IFS=$OLDIFS
}

# Utility function to get the filename at line number
# from the catch-all array csr
function resolve() {
    with_linenum=${2:-1}
    temp=$(echo ${csr[$1 - 1]} | sed -E "s/"$'\E'"\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g")
    if [[ $is_git_command == 1 ]]; then
        echo $temp | awk '{ print $NF }' | tr -d '[[:cntrl:]]'
    else
        if [[ $with_linenum == 1 ]]; then
            echo $temp | perl -pe's/^\s*[0-9]+\s+([^\s:]*):*([0-9]+)*:*.*$/\1 \2/'
        else
            echo $temp | perl -pe's/^\s*[0-9]+\s+([^\s:]*):*([0-9]+)*:*.*$/\1/'
        fi
    fi
}

# Utility function to open a file at line number
# Usage:
# openEditorAt <file> <lineno>
function openEditorAt() {
    if [[ -z $2 ]]; then
        $EDITOR $1
    else
        if [[ $EDITOR =~ "emacs" ]]; then
            $EDITOR +$2 $1
        else
            $EDITOR $1:$2
        fi
    fi
}

# Utility function to compare versions
function compare_version_lesser() {
    test "$(echo "$@" | tr " " "\n" | sort -nr | head -n 1)" != "$1";
}

# With all the stuff around bash and colors,
# this command is useful to find out what exactly being
# displayed on the terminal
# Usage:
# ls | show_hidden
alias show_hidden="tr -dc '[:print:]' | od -c"
alias ci='CSEARCHINDEX="$(git rev-parse --show-toplevel)"/.csearchindex; cindex .'

# Is the argument a number ?
is_num_result=""
function is_num() {
    if [[ $1 =~ ^[0-9]+$ ]]; then
        is_num_result="yes"
    else
        is_num_result="no"
    fi
}

# Is the command being run a generating command
# (from which a further action may be performed:
# git status gives a list of modified files and
# you choose a file to open or diff, or
# git branch gives a list of branches to checkout)
is_generating_command="no"
function is_gen_command() {
    # Currently only two generating command trees
    # f and git status | show | log | branch.
    arg=$1
    if [[ $1 =~ -- ]]; then
        arg=$2
    fi
    if [[ $arg == "status" ||
          $arg == "show" ||
          $arg == "log" ||
          $arg == "cpplint" ||
          $arg == "branch" ]]; then
        if [[ $arg == "cpplint" ]]; then
            is_git_command=0
        fi
        is_generating_command="yes"
    else
        is_generating_command="no"
    fi
}

# Is my workspace dirty ? (for this branch)
clean="no"
function is_workspace_dirty() {
    if [[ ${csr[@]} =~ "working directory clean" ]]; then
        clean="yes"; else clean="no";
    fi
}

# Run a git command with special conditions
# Examples of conditions include:
# 1) Is this a generating command ? (command which produces output
#   from which you would need to perform further actions)
# 2) Is the argument to the command a number ?
is_git_command=0
function git_command() {
    is_git_command=1
    is_generating_command="no"
    numbered_command $@
}

function git_generating_command() {
    is_git_command=1
    is_generating_command="yes"
    numbered_command $@
}

function numbered_generating_command() {
    is_generating_command="yes"
    is_git_command=0
    numbered_command $@
}

function numbered_command() {
    clean="yes"
    #is_gen_command $@
    OLDIFS=$IFS

    command=$1
    # Either there was a git generating command or
    # a f() generating command
    if [[ $is_generating_command == "yes" ]]; then
        if [[ $is_git_command == 1 ]]; then
            command='git'
        fi
        arg=$@
        is_num ${@: -1}
        if [[ $is_num_result == "yes" ]]; then
            arg="${@:1:$(($#-1))} $(resolve ${@: -1})"
        fi
        IFS=$' ' rarg=($arg) IFS=$OLDIFS
        IFS=$'\n' csr=($(script -q /dev/null $command ${rarg[@]} | nl))

        is_workspace_dirty
        if [[ $1 == "status" && $clean == "yes" ]]; then
            $command $@;
        else
            printf '%s\n' "${csr[@]}"
        fi
    else
        is_num $2
        if [[ $is_git_command == 1 ]]; then
            command='git'
        fi
        # $3 is any other options which were given
        if [[ $is_num_result == "yes" ]]; then
            $command $1 $3 $(resolve $2 0)
        else
            $command $1 $3 $2
        fi
    fi
    IFS=$OLDIFS
}

# Function to find (and open if found) files
# Arguments can include the filename or
# optionally a number which is an option
# from a previously run generating command.
function fo() {
    is_num $1
    # open dir option only applicable for numbered arguments
    # since there can be many matches for an arbitrary filename
    open_dir=${2:-0}
    if [[ $is_num_result == "yes" ]]; then
        if [[ $open_dir == 1 ]]; then
            pushd $(dirname $(resolve $1 0))
        else
            openEditorAt $(resolve $1)
        fi
    else
        OLDIFS=$IFS
        IFS=$'\n' csr=($(script -q /dev/null find . -name "$1" | nl))
        printf '%s\n' "${csr[@]}"
        IFS=$OLDIFS

        #
        # If only one result, take me there already!
        #
        if [ ${#csr[@]} -eq 1 ]; then
            if [[ $open_dir == 1 ]]; then
                pushd $(dirname $(resolve 1 0))
            else
                r 1
            fi
        fi
    fi
}

function grm() {
    rm `resolve $1 0`
}

function gcm() {
    git commit -a -m "$@"
}

######################################################################
# GIT COMMANDS -
# A repository of git commands wrapped in a number-referencing wrapper
# which makes it easy to run subsequent commands
# Usage:
# <command> [optional line number] <arguments that may follow the
# original command>
######################################################################
#function gch() { filename=$(resolve $1 0); git checkout $2 $filename; }
alias gch='git_command checkout'
alias gd='git_command diff '
alias ga='git_command add '

#normal git log
alias gl='git_command log'

# git log for numbered access
alias glp='git_generating_command --no-pager log -5'
alias gan='git_command annotate '
alias gr='git_command reset '
alias gsr='git reset --soft HEAD~'
alias gs='git_generating_command status'
alias gb='git_generating_command branch'
alias g='git'
alias grp='git review post'
alias grs='EDITOR=emacs git review submit'
alias gro='git review open'
alias gsh='git show'
alias gshn='git_generating_command show --name-only'
alias gp='kinit; git pull && update_csearch 1'
alias gtl='pushd $(git rev-parse --show-toplevel)'
alias gsc='git_generating_command diff master --name-only'
alias gcl='numbered_command cpplint'

#
# TODO list! (Help me out! :) )
#
# awesome-to-have: fo can autocomplete filenames to open
# perhaps: http://unix.stackexchange.com/questions/28283/autocomplete-of-filename-in-directory



